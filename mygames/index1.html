<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Dash</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.70.0/phaser.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
        body {
            margin: 0;
            background: #0a0a1a;
            font-family: 'Orbitron', sans-serif;
            overflow: hidden;
        }
        .game-ui { 
            position: fixed;
            padding: 20px;
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
        }
        #score-display {
            top: 20px;
            left: 20px;
        }
        #controls-display {
            bottom: 20px;
            right: 20px;
        }
    </style>
</head>
<body>
    <div id="score-display" class="game-ui">
        Score: <span id="score">0</span><br>
        Lives: <span id="lives">3</span>
    </div>
    <div id="controls-display" class="game-ui">
        ← → : Move<br>
        SPACE : Jump<br>
        SHIFT : Dash
    </div>
    <div id="game"></div>

    <script>
        const config = {
            type: Phaser.AUTO,
            width: window.innerWidth,
            height: window.innerHeight,
            parent: 'game',
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 500 },
                    debug: false
                }
            },
            scene: {
                preload: preload,
                create: create,
                update: update
            }
        };

        const gameState = {
            score: 0,
            lives: 3,
            speed: 300,
            isJumping: false,
            isDashing: false,
            canDash: true,
            platforms: null,
            obstacles: null,
            coins: null
        };

        const game = new Phaser.Game(config);

        function preload() {
            // Generate game assets
            const graphics = this.add.graphics();
            
            // Player
            graphics.fillStyle(0x00ffff);
            graphics.fillRect(0, 0, 32, 32);
            graphics.generateTexture('player', 32, 32);
            
            // Platform
            graphics.clear();
            graphics.fillStyle(0x0088ff);
            graphics.fillRect(0, 0, 100, 20);
            graphics.generateTexture('platform', 100, 20);
            
            // Obstacle
            graphics.clear();
            graphics.fillStyle(0xff0066);
            graphics.fillRect(0, 0, 30, 30);
            graphics.generateTexture('obstacle', 30, 30);
            
            // Coin
            graphics.clear();
            graphics.fillStyle(0xffff00);
            graphics.fillCircle(10, 10, 10);
            graphics.generateTexture('coin', 20, 20);
        }

        function create() {
            // Create player
            this.player = this.physics.add.sprite(100, 100, 'player');
            this.player.setCollideWorldBounds(true);

            // Create platforms group
            gameState.platforms = this.physics.add.staticGroup();
            createPlatforms.call(this);

            // Create obstacles and coins groups
            gameState.obstacles = this.physics.add.group();
            gameState.coins = this.physics.add.group();

            // Setup collisions
            this.physics.add.collider(this.player, gameState.platforms);
            this.physics.add.overlap(this.player, gameState.obstacles, hitObstacle, null, this);
            this.physics.add.overlap(this.player, gameState.coins, collectCoin, null, this);

            // Controls
            this.cursors = this.input.keyboard.createCursorKeys();
            this.shiftKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SHIFT);

            // Start spawning
            this.time.addEvent({
                delay: 2000,
                callback: spawnObstacles,
                callbackScope: this,
                loop: true
            });

            this.time.addEvent({
                delay: 1000,
                callback: spawnCoins,
                callbackScope: this,
                loop: true
            });
        }

        function update() {
            // Player movement
            if (this.cursors.left.isDown) {
                this.player.setVelocityX(-gameState.speed);
            } else if (this.cursors.right.isDown) {
                this.player.setVelocityX(gameState.speed);
            } else {
                this.player.setVelocityX(0);
            }

            // Jumping
            if (this.cursors.space.isDown && this.player.body.touching.down) {
                this.player.setVelocityY(-400);
            }

            // Dashing
            if (this.shiftKey.isDown && gameState.canDash) {
                dash.call(this);
            }

            // Move objects
            gameState.obstacles.children.iterate(function(obstacle) {
                if (obstacle) {
                    obstacle.y += 3;
                    if (obstacle.y > config.height) {
                        obstacle.destroy();
                    }
                }
            });

            gameState.coins.children.iterate(function(coin) {
                if (coin) {
                    coin.y += 2;
                    if (coin.y > config.height) {
                        coin.destroy();
                    }
                }
            });

            // Update score display
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('lives').textContent = gameState.lives;
        }

        function createPlatforms() {
            // Create main platform
            gameState.platforms.create(config.width/2, config.height-20, 'platform')
                .setScale(config.width/100, 1)
                .refreshBody();
        }

        function spawnObstacles() {
            const x = Phaser.Math.Between(0, config.width);
            const obstacle = gameState.obstacles.create(x, 0, 'obstacle');
            obstacle.setTint(0xff0066);
        }

        function spawnCoins() {
            const x = Phaser.Math.Between(0, config.width);
            const coin = gameState.coins.create(x, 0, 'coin');
            coin.setTint(0xffff00);
        }

        function hitObstacle() {
            if (gameState.isDashing) return;
            
            gameState.lives--;
            if (gameState.lives <= 0) {
                this.scene.restart();
                gameState.score = 0;
                gameState.lives = 3;
            }
        }

        function collectCoin(player, coin) {
            coin.destroy();
            gameState.score += 10;
        }

        function dash() {
            if (!gameState.canDash) return;
            
            gameState.isDashing = true;
            gameState.canDash = false;
            
            // Dash effect
            this.player.setTint(0xff00ff);
            
            // Reset after dash
            this.time.delayedCall(200, () => {
                gameState.isDashing = false;
                this.player.setTint(0x00ffff);
            });
            
            // Dash cooldown
            this.time.delayedCall(1000, () => {
                gameState.canDash = true;
            });
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            game.scale.resize(window.innerWidth, window.innerHeight);
            createPlatforms.call(game.scene.scenes[0]);
        });
    </script>
</body>
</html>